// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dnd5e.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dnd5e_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dnd5e_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dnd5e_2eproto;
namespace dnd5e {
class ApiItem;
struct ApiItemDefaultTypeInternal;
extern ApiItemDefaultTypeInternal _ApiItem_default_instance_;
class GetEndpointsRequest;
struct GetEndpointsRequestDefaultTypeInternal;
extern GetEndpointsRequestDefaultTypeInternal _GetEndpointsRequest_default_instance_;
class GetEndpointsResponse;
struct GetEndpointsResponseDefaultTypeInternal;
extern GetEndpointsResponseDefaultTypeInternal _GetEndpointsResponse_default_instance_;
class GetItemRequest;
struct GetItemRequestDefaultTypeInternal;
extern GetItemRequestDefaultTypeInternal _GetItemRequest_default_instance_;
class GetItemResponse;
struct GetItemResponseDefaultTypeInternal;
extern GetItemResponseDefaultTypeInternal _GetItemResponse_default_instance_;
class GetListRequest;
struct GetListRequestDefaultTypeInternal;
extern GetListRequestDefaultTypeInternal _GetListRequest_default_instance_;
class GetListResponse;
struct GetListResponseDefaultTypeInternal;
extern GetListResponseDefaultTypeInternal _GetListResponse_default_instance_;
class HealthCheckRequest;
struct HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
struct HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class SearchItemsRequest;
struct SearchItemsRequestDefaultTypeInternal;
extern SearchItemsRequestDefaultTypeInternal _SearchItemsRequest_default_instance_;
class SearchItemsResponse;
struct SearchItemsResponseDefaultTypeInternal;
extern SearchItemsResponseDefaultTypeInternal _SearchItemsResponse_default_instance_;
class SearchResult;
struct SearchResultDefaultTypeInternal;
extern SearchResultDefaultTypeInternal _SearchResult_default_instance_;
}  // namespace dnd5e
PROTOBUF_NAMESPACE_OPEN
template<> ::dnd5e::ApiItem* Arena::CreateMaybeMessage<::dnd5e::ApiItem>(Arena*);
template<> ::dnd5e::GetEndpointsRequest* Arena::CreateMaybeMessage<::dnd5e::GetEndpointsRequest>(Arena*);
template<> ::dnd5e::GetEndpointsResponse* Arena::CreateMaybeMessage<::dnd5e::GetEndpointsResponse>(Arena*);
template<> ::dnd5e::GetItemRequest* Arena::CreateMaybeMessage<::dnd5e::GetItemRequest>(Arena*);
template<> ::dnd5e::GetItemResponse* Arena::CreateMaybeMessage<::dnd5e::GetItemResponse>(Arena*);
template<> ::dnd5e::GetListRequest* Arena::CreateMaybeMessage<::dnd5e::GetListRequest>(Arena*);
template<> ::dnd5e::GetListResponse* Arena::CreateMaybeMessage<::dnd5e::GetListResponse>(Arena*);
template<> ::dnd5e::HealthCheckRequest* Arena::CreateMaybeMessage<::dnd5e::HealthCheckRequest>(Arena*);
template<> ::dnd5e::HealthCheckResponse* Arena::CreateMaybeMessage<::dnd5e::HealthCheckResponse>(Arena*);
template<> ::dnd5e::SearchItemsRequest* Arena::CreateMaybeMessage<::dnd5e::SearchItemsRequest>(Arena*);
template<> ::dnd5e::SearchItemsResponse* Arena::CreateMaybeMessage<::dnd5e::SearchItemsResponse>(Arena*);
template<> ::dnd5e::SearchResult* Arena::CreateMaybeMessage<::dnd5e::SearchResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dnd5e {

enum HealthCheckResponse_ServingStatus : int {
  HealthCheckResponse_ServingStatus_UNKNOWN = 0,
  HealthCheckResponse_ServingStatus_SERVING = 1,
  HealthCheckResponse_ServingStatus_NOT_SERVING = 2,
  HealthCheckResponse_ServingStatus_HealthCheckResponse_ServingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HealthCheckResponse_ServingStatus_HealthCheckResponse_ServingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HealthCheckResponse_ServingStatus_IsValid(int value);
constexpr HealthCheckResponse_ServingStatus HealthCheckResponse_ServingStatus_ServingStatus_MIN = HealthCheckResponse_ServingStatus_UNKNOWN;
constexpr HealthCheckResponse_ServingStatus HealthCheckResponse_ServingStatus_ServingStatus_MAX = HealthCheckResponse_ServingStatus_NOT_SERVING;
constexpr int HealthCheckResponse_ServingStatus_ServingStatus_ARRAYSIZE = HealthCheckResponse_ServingStatus_ServingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HealthCheckResponse_ServingStatus_descriptor();
template<typename T>
inline const std::string& HealthCheckResponse_ServingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HealthCheckResponse_ServingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HealthCheckResponse_ServingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HealthCheckResponse_ServingStatus_descriptor(), enum_t_value);
}
inline bool HealthCheckResponse_ServingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HealthCheckResponse_ServingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HealthCheckResponse_ServingStatus>(
    HealthCheckResponse_ServingStatus_descriptor(), name, value);
}
// ===================================================================

class GetEndpointsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dnd5e.GetEndpointsRequest) */ {
 public:
  inline GetEndpointsRequest() : GetEndpointsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetEndpointsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEndpointsRequest(const GetEndpointsRequest& from);
  GetEndpointsRequest(GetEndpointsRequest&& from) noexcept
    : GetEndpointsRequest() {
    *this = ::std::move(from);
  }

  inline GetEndpointsRequest& operator=(const GetEndpointsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEndpointsRequest& operator=(GetEndpointsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEndpointsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEndpointsRequest* internal_default_instance() {
    return reinterpret_cast<const GetEndpointsRequest*>(
               &_GetEndpointsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetEndpointsRequest& a, GetEndpointsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEndpointsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEndpointsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEndpointsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEndpointsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetEndpointsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetEndpointsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.GetEndpointsRequest";
  }
  protected:
  explicit GetEndpointsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dnd5e.GetEndpointsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class GetEndpointsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.GetEndpointsResponse) */ {
 public:
  inline GetEndpointsResponse() : GetEndpointsResponse(nullptr) {}
  ~GetEndpointsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetEndpointsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEndpointsResponse(const GetEndpointsResponse& from);
  GetEndpointsResponse(GetEndpointsResponse&& from) noexcept
    : GetEndpointsResponse() {
    *this = ::std::move(from);
  }

  inline GetEndpointsResponse& operator=(const GetEndpointsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEndpointsResponse& operator=(GetEndpointsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEndpointsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEndpointsResponse* internal_default_instance() {
    return reinterpret_cast<const GetEndpointsResponse*>(
               &_GetEndpointsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetEndpointsResponse& a, GetEndpointsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEndpointsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEndpointsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEndpointsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEndpointsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEndpointsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEndpointsResponse& from) {
    GetEndpointsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEndpointsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.GetEndpointsResponse";
  }
  protected:
  explicit GetEndpointsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 1,
    kTotalCountFieldNumber = 2,
  };
  // repeated string endpoints = 1;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoints();
  private:
  const std::string& _internal_endpoints(int index) const;
  std::string* _internal_add_endpoints();
  public:

  // int32 total_count = 2;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.GetEndpointsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoints_;
    int32_t total_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class GetListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.GetListRequest) */ {
 public:
  inline GetListRequest() : GetListRequest(nullptr) {}
  ~GetListRequest() override;
  explicit PROTOBUF_CONSTEXPR GetListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListRequest(const GetListRequest& from);
  GetListRequest(GetListRequest&& from) noexcept
    : GetListRequest() {
    *this = ::std::move(from);
  }

  inline GetListRequest& operator=(const GetListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListRequest& operator=(GetListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListRequest* internal_default_instance() {
    return reinterpret_cast<const GetListRequest*>(
               &_GetListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetListRequest& a, GetListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListRequest& from) {
    GetListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.GetListRequest";
  }
  protected:
  explicit GetListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kPageFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string endpoint = 1;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // int32 page = 2;
  void clear_page();
  int32_t page() const;
  void set_page(int32_t value);
  private:
  int32_t _internal_page() const;
  void _internal_set_page(int32_t value);
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.GetListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    int32_t page_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class GetListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.GetListResponse) */ {
 public:
  inline GetListResponse() : GetListResponse(nullptr) {}
  ~GetListResponse() override;
  explicit PROTOBUF_CONSTEXPR GetListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListResponse(const GetListResponse& from);
  GetListResponse(GetListResponse&& from) noexcept
    : GetListResponse() {
    *this = ::std::move(from);
  }

  inline GetListResponse& operator=(const GetListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListResponse& operator=(GetListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListResponse* internal_default_instance() {
    return reinterpret_cast<const GetListResponse*>(
               &_GetListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetListResponse& a, GetListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListResponse& from) {
    GetListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.GetListResponse";
  }
  protected:
  explicit GetListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 5,
    kEndpointFieldNumber = 1,
    kTotalCountFieldNumber = 2,
    kPageFieldNumber = 3,
    kPageSizeFieldNumber = 4,
    kHasMoreFieldNumber = 6,
  };
  // repeated .dnd5e.ApiItem items = 5;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::dnd5e::ApiItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::ApiItem >*
      mutable_items();
  private:
  const ::dnd5e::ApiItem& _internal_items(int index) const;
  ::dnd5e::ApiItem* _internal_add_items();
  public:
  const ::dnd5e::ApiItem& items(int index) const;
  ::dnd5e::ApiItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::ApiItem >&
      items() const;

  // string endpoint = 1;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // int32 total_count = 2;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // int32 page = 3;
  void clear_page();
  int32_t page() const;
  void set_page(int32_t value);
  private:
  int32_t _internal_page() const;
  void _internal_set_page(int32_t value);
  public:

  // int32 page_size = 4;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // bool has_more = 6;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.GetListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::ApiItem > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    int32_t total_count_;
    int32_t page_;
    int32_t page_size_;
    bool has_more_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class GetItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.GetItemRequest) */ {
 public:
  inline GetItemRequest() : GetItemRequest(nullptr) {}
  ~GetItemRequest() override;
  explicit PROTOBUF_CONSTEXPR GetItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetItemRequest(const GetItemRequest& from);
  GetItemRequest(GetItemRequest&& from) noexcept
    : GetItemRequest() {
    *this = ::std::move(from);
  }

  inline GetItemRequest& operator=(const GetItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetItemRequest& operator=(GetItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetItemRequest* internal_default_instance() {
    return reinterpret_cast<const GetItemRequest*>(
               &_GetItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetItemRequest& a, GetItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetItemRequest& from) {
    GetItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.GetItemRequest";
  }
  protected:
  explicit GetItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // string endpoint = 1;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.GetItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class GetItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.GetItemResponse) */ {
 public:
  inline GetItemResponse() : GetItemResponse(nullptr) {}
  ~GetItemResponse() override;
  explicit PROTOBUF_CONSTEXPR GetItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetItemResponse(const GetItemResponse& from);
  GetItemResponse(GetItemResponse&& from) noexcept
    : GetItemResponse() {
    *this = ::std::move(from);
  }

  inline GetItemResponse& operator=(const GetItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetItemResponse& operator=(GetItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetItemResponse* internal_default_instance() {
    return reinterpret_cast<const GetItemResponse*>(
               &_GetItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetItemResponse& a, GetItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetItemResponse& from) {
    GetItemResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.GetItemResponse";
  }
  protected:
  explicit GetItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawDataFieldNumber = 2,
    kItemFieldNumber = 1,
  };
  // string raw_data = 2;
  void clear_raw_data();
  const std::string& raw_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_data();
  PROTOBUF_NODISCARD std::string* release_raw_data();
  void set_allocated_raw_data(std::string* raw_data);
  private:
  const std::string& _internal_raw_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_data(const std::string& value);
  std::string* _internal_mutable_raw_data();
  public:

  // .dnd5e.ApiItem item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::dnd5e::ApiItem& item() const;
  PROTOBUF_NODISCARD ::dnd5e::ApiItem* release_item();
  ::dnd5e::ApiItem* mutable_item();
  void set_allocated_item(::dnd5e::ApiItem* item);
  private:
  const ::dnd5e::ApiItem& _internal_item() const;
  ::dnd5e::ApiItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::dnd5e::ApiItem* item);
  ::dnd5e::ApiItem* unsafe_arena_release_item();

  // @@protoc_insertion_point(class_scope:dnd5e.GetItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
    ::dnd5e::ApiItem* item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class SearchItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.SearchItemsRequest) */ {
 public:
  inline SearchItemsRequest() : SearchItemsRequest(nullptr) {}
  ~SearchItemsRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchItemsRequest(const SearchItemsRequest& from);
  SearchItemsRequest(SearchItemsRequest&& from) noexcept
    : SearchItemsRequest() {
    *this = ::std::move(from);
  }

  inline SearchItemsRequest& operator=(const SearchItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchItemsRequest& operator=(SearchItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchItemsRequest* internal_default_instance() {
    return reinterpret_cast<const SearchItemsRequest*>(
               &_SearchItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SearchItemsRequest& a, SearchItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchItemsRequest& from) {
    SearchItemsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchItemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.SearchItemsRequest";
  }
  protected:
  explicit SearchItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 2,
    kQueryFieldNumber = 1,
    kMaxResultsFieldNumber = 3,
  };
  // repeated string endpoints = 2;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoints();
  private:
  const std::string& _internal_endpoints(int index) const;
  std::string* _internal_add_endpoints();
  public:

  // string query = 1;
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // int32 max_results = 3;
  void clear_max_results();
  int32_t max_results() const;
  void set_max_results(int32_t value);
  private:
  int32_t _internal_max_results() const;
  void _internal_set_max_results(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.SearchItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    int32_t max_results_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class SearchItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.SearchItemsResponse) */ {
 public:
  inline SearchItemsResponse() : SearchItemsResponse(nullptr) {}
  ~SearchItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchItemsResponse(const SearchItemsResponse& from);
  SearchItemsResponse(SearchItemsResponse&& from) noexcept
    : SearchItemsResponse() {
    *this = ::std::move(from);
  }

  inline SearchItemsResponse& operator=(const SearchItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchItemsResponse& operator=(SearchItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchItemsResponse* internal_default_instance() {
    return reinterpret_cast<const SearchItemsResponse*>(
               &_SearchItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SearchItemsResponse& a, SearchItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchItemsResponse& from) {
    SearchItemsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.SearchItemsResponse";
  }
  protected:
  explicit SearchItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kQueryFieldNumber = 1,
    kTotalFoundFieldNumber = 3,
  };
  // repeated .dnd5e.SearchResult results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::dnd5e::SearchResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::SearchResult >*
      mutable_results();
  private:
  const ::dnd5e::SearchResult& _internal_results(int index) const;
  ::dnd5e::SearchResult* _internal_add_results();
  public:
  const ::dnd5e::SearchResult& results(int index) const;
  ::dnd5e::SearchResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::SearchResult >&
      results() const;

  // string query = 1;
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // int32 total_found = 3;
  void clear_total_found();
  int32_t total_found() const;
  void set_total_found(int32_t value);
  private:
  int32_t _internal_total_found() const;
  void _internal_set_total_found(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.SearchItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::SearchResult > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    int32_t total_found_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dnd5e.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dnd5e.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  ~HealthCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckResponse& from) {
    HealthCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HealthCheckResponse_ServingStatus ServingStatus;
  static constexpr ServingStatus UNKNOWN =
    HealthCheckResponse_ServingStatus_UNKNOWN;
  static constexpr ServingStatus SERVING =
    HealthCheckResponse_ServingStatus_SERVING;
  static constexpr ServingStatus NOT_SERVING =
    HealthCheckResponse_ServingStatus_NOT_SERVING;
  static inline bool ServingStatus_IsValid(int value) {
    return HealthCheckResponse_ServingStatus_IsValid(value);
  }
  static constexpr ServingStatus ServingStatus_MIN =
    HealthCheckResponse_ServingStatus_ServingStatus_MIN;
  static constexpr ServingStatus ServingStatus_MAX =
    HealthCheckResponse_ServingStatus_ServingStatus_MAX;
  static constexpr int ServingStatus_ARRAYSIZE =
    HealthCheckResponse_ServingStatus_ServingStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ServingStatus_descriptor() {
    return HealthCheckResponse_ServingStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ServingStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ServingStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ServingStatus_Name.");
    return HealthCheckResponse_ServingStatus_Name(enum_t_value);
  }
  static inline bool ServingStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ServingStatus* value) {
    return HealthCheckResponse_ServingStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .dnd5e.HealthCheckResponse.ServingStatus status = 1;
  void clear_status();
  ::dnd5e::HealthCheckResponse_ServingStatus status() const;
  void set_status(::dnd5e::HealthCheckResponse_ServingStatus value);
  private:
  ::dnd5e::HealthCheckResponse_ServingStatus _internal_status() const;
  void _internal_set_status(::dnd5e::HealthCheckResponse_ServingStatus value);
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int64_t timestamp_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class ApiItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.ApiItem) */ {
 public:
  inline ApiItem() : ApiItem(nullptr) {}
  ~ApiItem() override;
  explicit PROTOBUF_CONSTEXPR ApiItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiItem(const ApiItem& from);
  ApiItem(ApiItem&& from) noexcept
    : ApiItem() {
    *this = ::std::move(from);
  }

  inline ApiItem& operator=(const ApiItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiItem& operator=(ApiItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiItem* internal_default_instance() {
    return reinterpret_cast<const ApiItem*>(
               &_ApiItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApiItem& a, ApiItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApiItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApiItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApiItem& from) {
    ApiItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApiItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.ApiItem";
  }
  protected:
  explicit ApiItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kNameFieldNumber = 2,
    kUrlFieldNumber = 3,
    kEndpointFieldNumber = 4,
  };
  // string index = 1;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string endpoint = 4;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.ApiItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// -------------------------------------------------------------------

class SearchResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dnd5e.SearchResult) */ {
 public:
  inline SearchResult() : SearchResult(nullptr) {}
  ~SearchResult() override;
  explicit PROTOBUF_CONSTEXPR SearchResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResult(const SearchResult& from);
  SearchResult(SearchResult&& from) noexcept
    : SearchResult() {
    *this = ::std::move(from);
  }

  inline SearchResult& operator=(const SearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResult& operator=(SearchResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResult* internal_default_instance() {
    return reinterpret_cast<const SearchResult*>(
               &_SearchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SearchResult& a, SearchResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchResult& from) {
    SearchResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dnd5e.SearchResult";
  }
  protected:
  explicit SearchResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchedFieldFieldNumber = 2,
    kItemFieldNumber = 1,
    kRelevanceScoreFieldNumber = 3,
  };
  // string matched_field = 2;
  void clear_matched_field();
  const std::string& matched_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_matched_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_matched_field();
  PROTOBUF_NODISCARD std::string* release_matched_field();
  void set_allocated_matched_field(std::string* matched_field);
  private:
  const std::string& _internal_matched_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_matched_field(const std::string& value);
  std::string* _internal_mutable_matched_field();
  public:

  // .dnd5e.ApiItem item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::dnd5e::ApiItem& item() const;
  PROTOBUF_NODISCARD ::dnd5e::ApiItem* release_item();
  ::dnd5e::ApiItem* mutable_item();
  void set_allocated_item(::dnd5e::ApiItem* item);
  private:
  const ::dnd5e::ApiItem& _internal_item() const;
  ::dnd5e::ApiItem* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::dnd5e::ApiItem* item);
  ::dnd5e::ApiItem* unsafe_arena_release_item();

  // float relevance_score = 3;
  void clear_relevance_score();
  float relevance_score() const;
  void set_relevance_score(float value);
  private:
  float _internal_relevance_score() const;
  void _internal_set_relevance_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:dnd5e.SearchResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr matched_field_;
    ::dnd5e::ApiItem* item_;
    float relevance_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetEndpointsRequest

// -------------------------------------------------------------------

// GetEndpointsResponse

// repeated string endpoints = 1;
inline int GetEndpointsResponse::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int GetEndpointsResponse::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void GetEndpointsResponse::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline std::string* GetEndpointsResponse::add_endpoints() {
  std::string* _s = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.GetEndpointsResponse.endpoints)
  return _s;
}
inline const std::string& GetEndpointsResponse::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const std::string& GetEndpointsResponse::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.GetEndpointsResponse.endpoints)
  return _internal_endpoints(index);
}
inline std::string* GetEndpointsResponse::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:dnd5e.GetEndpointsResponse.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline void GetEndpointsResponse::set_endpoints(int index, const std::string& value) {
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetEndpointsResponse.endpoints)
}
inline void GetEndpointsResponse::set_endpoints(int index, std::string&& value) {
  _impl_.endpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dnd5e.GetEndpointsResponse.endpoints)
}
inline void GetEndpointsResponse::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dnd5e.GetEndpointsResponse.endpoints)
}
inline void GetEndpointsResponse::set_endpoints(int index, const char* value, size_t size) {
  _impl_.endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dnd5e.GetEndpointsResponse.endpoints)
}
inline std::string* GetEndpointsResponse::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline void GetEndpointsResponse::add_endpoints(const std::string& value) {
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dnd5e.GetEndpointsResponse.endpoints)
}
inline void GetEndpointsResponse::add_endpoints(std::string&& value) {
  _impl_.endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dnd5e.GetEndpointsResponse.endpoints)
}
inline void GetEndpointsResponse::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dnd5e.GetEndpointsResponse.endpoints)
}
inline void GetEndpointsResponse::add_endpoints(const char* value, size_t size) {
  _impl_.endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dnd5e.GetEndpointsResponse.endpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetEndpointsResponse::endpoints() const {
  // @@protoc_insertion_point(field_list:dnd5e.GetEndpointsResponse.endpoints)
  return _impl_.endpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetEndpointsResponse::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.GetEndpointsResponse.endpoints)
  return &_impl_.endpoints_;
}

// int32 total_count = 2;
inline void GetEndpointsResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t GetEndpointsResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t GetEndpointsResponse::total_count() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetEndpointsResponse.total_count)
  return _internal_total_count();
}
inline void GetEndpointsResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void GetEndpointsResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetEndpointsResponse.total_count)
}

// -------------------------------------------------------------------

// GetListRequest

// string endpoint = 1;
inline void GetListRequest::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& GetListRequest::endpoint() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListRequest.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListRequest::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.GetListRequest.endpoint)
}
inline std::string* GetListRequest::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:dnd5e.GetListRequest.endpoint)
  return _s;
}
inline const std::string& GetListRequest::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void GetListRequest::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListRequest::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListRequest::release_endpoint() {
  // @@protoc_insertion_point(field_release:dnd5e.GetListRequest.endpoint)
  return _impl_.endpoint_.Release();
}
inline void GetListRequest::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.GetListRequest.endpoint)
}

// int32 page = 2;
inline void GetListRequest::clear_page() {
  _impl_.page_ = 0;
}
inline int32_t GetListRequest::_internal_page() const {
  return _impl_.page_;
}
inline int32_t GetListRequest::page() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListRequest.page)
  return _internal_page();
}
inline void GetListRequest::_internal_set_page(int32_t value) {
  
  _impl_.page_ = value;
}
inline void GetListRequest::set_page(int32_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetListRequest.page)
}

// int32 page_size = 3;
inline void GetListRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t GetListRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t GetListRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListRequest.page_size)
  return _internal_page_size();
}
inline void GetListRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void GetListRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetListRequest.page_size)
}

// -------------------------------------------------------------------

// GetListResponse

// string endpoint = 1;
inline void GetListResponse::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& GetListResponse::endpoint() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListResponse.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListResponse::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.GetListResponse.endpoint)
}
inline std::string* GetListResponse::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:dnd5e.GetListResponse.endpoint)
  return _s;
}
inline const std::string& GetListResponse::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void GetListResponse::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListResponse::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListResponse::release_endpoint() {
  // @@protoc_insertion_point(field_release:dnd5e.GetListResponse.endpoint)
  return _impl_.endpoint_.Release();
}
inline void GetListResponse::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.GetListResponse.endpoint)
}

// int32 total_count = 2;
inline void GetListResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t GetListResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t GetListResponse::total_count() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListResponse.total_count)
  return _internal_total_count();
}
inline void GetListResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void GetListResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetListResponse.total_count)
}

// int32 page = 3;
inline void GetListResponse::clear_page() {
  _impl_.page_ = 0;
}
inline int32_t GetListResponse::_internal_page() const {
  return _impl_.page_;
}
inline int32_t GetListResponse::page() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListResponse.page)
  return _internal_page();
}
inline void GetListResponse::_internal_set_page(int32_t value) {
  
  _impl_.page_ = value;
}
inline void GetListResponse::set_page(int32_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetListResponse.page)
}

// int32 page_size = 4;
inline void GetListResponse::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t GetListResponse::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t GetListResponse::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListResponse.page_size)
  return _internal_page_size();
}
inline void GetListResponse::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void GetListResponse::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetListResponse.page_size)
}

// repeated .dnd5e.ApiItem items = 5;
inline int GetListResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int GetListResponse::items_size() const {
  return _internal_items_size();
}
inline void GetListResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::dnd5e::ApiItem* GetListResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:dnd5e.GetListResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::ApiItem >*
GetListResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.GetListResponse.items)
  return &_impl_.items_;
}
inline const ::dnd5e::ApiItem& GetListResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::dnd5e::ApiItem& GetListResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListResponse.items)
  return _internal_items(index);
}
inline ::dnd5e::ApiItem* GetListResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::dnd5e::ApiItem* GetListResponse::add_items() {
  ::dnd5e::ApiItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:dnd5e.GetListResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::ApiItem >&
GetListResponse::items() const {
  // @@protoc_insertion_point(field_list:dnd5e.GetListResponse.items)
  return _impl_.items_;
}

// bool has_more = 6;
inline void GetListResponse::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool GetListResponse::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool GetListResponse::has_more() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetListResponse.has_more)
  return _internal_has_more();
}
inline void GetListResponse::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void GetListResponse::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:dnd5e.GetListResponse.has_more)
}

// -------------------------------------------------------------------

// GetItemRequest

// string endpoint = 1;
inline void GetItemRequest::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& GetItemRequest::endpoint() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetItemRequest.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetItemRequest::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.GetItemRequest.endpoint)
}
inline std::string* GetItemRequest::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:dnd5e.GetItemRequest.endpoint)
  return _s;
}
inline const std::string& GetItemRequest::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void GetItemRequest::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* GetItemRequest::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* GetItemRequest::release_endpoint() {
  // @@protoc_insertion_point(field_release:dnd5e.GetItemRequest.endpoint)
  return _impl_.endpoint_.Release();
}
inline void GetItemRequest::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.GetItemRequest.endpoint)
}

// string index = 2;
inline void GetItemRequest::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& GetItemRequest::index() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetItemRequest.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetItemRequest::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.GetItemRequest.index)
}
inline std::string* GetItemRequest::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:dnd5e.GetItemRequest.index)
  return _s;
}
inline const std::string& GetItemRequest::_internal_index() const {
  return _impl_.index_.Get();
}
inline void GetItemRequest::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* GetItemRequest::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* GetItemRequest::release_index() {
  // @@protoc_insertion_point(field_release:dnd5e.GetItemRequest.index)
  return _impl_.index_.Release();
}
inline void GetItemRequest::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.GetItemRequest.index)
}

// -------------------------------------------------------------------

// GetItemResponse

// .dnd5e.ApiItem item = 1;
inline bool GetItemResponse::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool GetItemResponse::has_item() const {
  return _internal_has_item();
}
inline void GetItemResponse::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::dnd5e::ApiItem& GetItemResponse::_internal_item() const {
  const ::dnd5e::ApiItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::ApiItem&>(
      ::dnd5e::_ApiItem_default_instance_);
}
inline const ::dnd5e::ApiItem& GetItemResponse::item() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetItemResponse.item)
  return _internal_item();
}
inline void GetItemResponse::unsafe_arena_set_allocated_item(
    ::dnd5e::ApiItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.GetItemResponse.item)
}
inline ::dnd5e::ApiItem* GetItemResponse::release_item() {
  
  ::dnd5e::ApiItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dnd5e::ApiItem* GetItemResponse::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:dnd5e.GetItemResponse.item)
  
  ::dnd5e::ApiItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::dnd5e::ApiItem* GetItemResponse::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::dnd5e::ApiItem>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::dnd5e::ApiItem* GetItemResponse::mutable_item() {
  ::dnd5e::ApiItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:dnd5e.GetItemResponse.item)
  return _msg;
}
inline void GetItemResponse::set_allocated_item(::dnd5e::ApiItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:dnd5e.GetItemResponse.item)
}

// string raw_data = 2;
inline void GetItemResponse::clear_raw_data() {
  _impl_.raw_data_.ClearToEmpty();
}
inline const std::string& GetItemResponse::raw_data() const {
  // @@protoc_insertion_point(field_get:dnd5e.GetItemResponse.raw_data)
  return _internal_raw_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetItemResponse::set_raw_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.GetItemResponse.raw_data)
}
inline std::string* GetItemResponse::mutable_raw_data() {
  std::string* _s = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:dnd5e.GetItemResponse.raw_data)
  return _s;
}
inline const std::string& GetItemResponse::_internal_raw_data() const {
  return _impl_.raw_data_.Get();
}
inline void GetItemResponse::_internal_set_raw_data(const std::string& value) {
  
  _impl_.raw_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetItemResponse::_internal_mutable_raw_data() {
  
  return _impl_.raw_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetItemResponse::release_raw_data() {
  // @@protoc_insertion_point(field_release:dnd5e.GetItemResponse.raw_data)
  return _impl_.raw_data_.Release();
}
inline void GetItemResponse::set_allocated_raw_data(std::string* raw_data) {
  if (raw_data != nullptr) {
    
  } else {
    
  }
  _impl_.raw_data_.SetAllocated(raw_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_data_.IsDefault()) {
    _impl_.raw_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.GetItemResponse.raw_data)
}

// -------------------------------------------------------------------

// SearchItemsRequest

// string query = 1;
inline void SearchItemsRequest::clear_query() {
  _impl_.query_.ClearToEmpty();
}
inline const std::string& SearchItemsRequest::query() const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchItemsRequest.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchItemsRequest::set_query(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.SearchItemsRequest.query)
}
inline std::string* SearchItemsRequest::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:dnd5e.SearchItemsRequest.query)
  return _s;
}
inline const std::string& SearchItemsRequest::_internal_query() const {
  return _impl_.query_.Get();
}
inline void SearchItemsRequest::_internal_set_query(const std::string& value) {
  
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchItemsRequest::_internal_mutable_query() {
  
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchItemsRequest::release_query() {
  // @@protoc_insertion_point(field_release:dnd5e.SearchItemsRequest.query)
  return _impl_.query_.Release();
}
inline void SearchItemsRequest::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.SearchItemsRequest.query)
}

// repeated string endpoints = 2;
inline int SearchItemsRequest::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int SearchItemsRequest::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void SearchItemsRequest::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline std::string* SearchItemsRequest::add_endpoints() {
  std::string* _s = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.SearchItemsRequest.endpoints)
  return _s;
}
inline const std::string& SearchItemsRequest::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const std::string& SearchItemsRequest::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchItemsRequest.endpoints)
  return _internal_endpoints(index);
}
inline std::string* SearchItemsRequest::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:dnd5e.SearchItemsRequest.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline void SearchItemsRequest::set_endpoints(int index, const std::string& value) {
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dnd5e.SearchItemsRequest.endpoints)
}
inline void SearchItemsRequest::set_endpoints(int index, std::string&& value) {
  _impl_.endpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dnd5e.SearchItemsRequest.endpoints)
}
inline void SearchItemsRequest::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dnd5e.SearchItemsRequest.endpoints)
}
inline void SearchItemsRequest::set_endpoints(int index, const char* value, size_t size) {
  _impl_.endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dnd5e.SearchItemsRequest.endpoints)
}
inline std::string* SearchItemsRequest::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline void SearchItemsRequest::add_endpoints(const std::string& value) {
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dnd5e.SearchItemsRequest.endpoints)
}
inline void SearchItemsRequest::add_endpoints(std::string&& value) {
  _impl_.endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dnd5e.SearchItemsRequest.endpoints)
}
inline void SearchItemsRequest::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dnd5e.SearchItemsRequest.endpoints)
}
inline void SearchItemsRequest::add_endpoints(const char* value, size_t size) {
  _impl_.endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dnd5e.SearchItemsRequest.endpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchItemsRequest::endpoints() const {
  // @@protoc_insertion_point(field_list:dnd5e.SearchItemsRequest.endpoints)
  return _impl_.endpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchItemsRequest::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.SearchItemsRequest.endpoints)
  return &_impl_.endpoints_;
}

// int32 max_results = 3;
inline void SearchItemsRequest::clear_max_results() {
  _impl_.max_results_ = 0;
}
inline int32_t SearchItemsRequest::_internal_max_results() const {
  return _impl_.max_results_;
}
inline int32_t SearchItemsRequest::max_results() const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchItemsRequest.max_results)
  return _internal_max_results();
}
inline void SearchItemsRequest::_internal_set_max_results(int32_t value) {
  
  _impl_.max_results_ = value;
}
inline void SearchItemsRequest::set_max_results(int32_t value) {
  _internal_set_max_results(value);
  // @@protoc_insertion_point(field_set:dnd5e.SearchItemsRequest.max_results)
}

// -------------------------------------------------------------------

// SearchItemsResponse

// string query = 1;
inline void SearchItemsResponse::clear_query() {
  _impl_.query_.ClearToEmpty();
}
inline const std::string& SearchItemsResponse::query() const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchItemsResponse.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchItemsResponse::set_query(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.SearchItemsResponse.query)
}
inline std::string* SearchItemsResponse::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:dnd5e.SearchItemsResponse.query)
  return _s;
}
inline const std::string& SearchItemsResponse::_internal_query() const {
  return _impl_.query_.Get();
}
inline void SearchItemsResponse::_internal_set_query(const std::string& value) {
  
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchItemsResponse::_internal_mutable_query() {
  
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchItemsResponse::release_query() {
  // @@protoc_insertion_point(field_release:dnd5e.SearchItemsResponse.query)
  return _impl_.query_.Release();
}
inline void SearchItemsResponse::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.SearchItemsResponse.query)
}

// repeated .dnd5e.SearchResult results = 2;
inline int SearchItemsResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int SearchItemsResponse::results_size() const {
  return _internal_results_size();
}
inline void SearchItemsResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::dnd5e::SearchResult* SearchItemsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:dnd5e.SearchItemsResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::SearchResult >*
SearchItemsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.SearchItemsResponse.results)
  return &_impl_.results_;
}
inline const ::dnd5e::SearchResult& SearchItemsResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::dnd5e::SearchResult& SearchItemsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchItemsResponse.results)
  return _internal_results(index);
}
inline ::dnd5e::SearchResult* SearchItemsResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::dnd5e::SearchResult* SearchItemsResponse::add_results() {
  ::dnd5e::SearchResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:dnd5e.SearchItemsResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dnd5e::SearchResult >&
SearchItemsResponse::results() const {
  // @@protoc_insertion_point(field_list:dnd5e.SearchItemsResponse.results)
  return _impl_.results_;
}

// int32 total_found = 3;
inline void SearchItemsResponse::clear_total_found() {
  _impl_.total_found_ = 0;
}
inline int32_t SearchItemsResponse::_internal_total_found() const {
  return _impl_.total_found_;
}
inline int32_t SearchItemsResponse::total_found() const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchItemsResponse.total_found)
  return _internal_total_found();
}
inline void SearchItemsResponse::_internal_set_total_found(int32_t value) {
  
  _impl_.total_found_ = value;
}
inline void SearchItemsResponse::set_total_found(int32_t value) {
  _internal_set_total_found(value);
  // @@protoc_insertion_point(field_set:dnd5e.SearchItemsResponse.total_found)
}

// -------------------------------------------------------------------

// HealthCheckRequest

// -------------------------------------------------------------------

// HealthCheckResponse

// .dnd5e.HealthCheckResponse.ServingStatus status = 1;
inline void HealthCheckResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::dnd5e::HealthCheckResponse_ServingStatus HealthCheckResponse::_internal_status() const {
  return static_cast< ::dnd5e::HealthCheckResponse_ServingStatus >(_impl_.status_);
}
inline ::dnd5e::HealthCheckResponse_ServingStatus HealthCheckResponse::status() const {
  // @@protoc_insertion_point(field_get:dnd5e.HealthCheckResponse.status)
  return _internal_status();
}
inline void HealthCheckResponse::_internal_set_status(::dnd5e::HealthCheckResponse_ServingStatus value) {
  
  _impl_.status_ = value;
}
inline void HealthCheckResponse::set_status(::dnd5e::HealthCheckResponse_ServingStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:dnd5e.HealthCheckResponse.status)
}

// string message = 2;
inline void HealthCheckResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::message() const {
  // @@protoc_insertion_point(field_get:dnd5e.HealthCheckResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.HealthCheckResponse.message)
}
inline std::string* HealthCheckResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.HealthCheckResponse.message)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HealthCheckResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_message() {
  // @@protoc_insertion_point(field_release:dnd5e.HealthCheckResponse.message)
  return _impl_.message_.Release();
}
inline void HealthCheckResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.HealthCheckResponse.message)
}

// int64 timestamp = 3;
inline void HealthCheckResponse::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t HealthCheckResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t HealthCheckResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:dnd5e.HealthCheckResponse.timestamp)
  return _internal_timestamp();
}
inline void HealthCheckResponse::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void HealthCheckResponse::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:dnd5e.HealthCheckResponse.timestamp)
}

// -------------------------------------------------------------------

// ApiItem

// string index = 1;
inline void ApiItem::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& ApiItem::index() const {
  // @@protoc_insertion_point(field_get:dnd5e.ApiItem.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApiItem::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.ApiItem.index)
}
inline std::string* ApiItem::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:dnd5e.ApiItem.index)
  return _s;
}
inline const std::string& ApiItem::_internal_index() const {
  return _impl_.index_.Get();
}
inline void ApiItem::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* ApiItem::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* ApiItem::release_index() {
  // @@protoc_insertion_point(field_release:dnd5e.ApiItem.index)
  return _impl_.index_.Release();
}
inline void ApiItem::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.ApiItem.index)
}

// string name = 2;
inline void ApiItem::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ApiItem::name() const {
  // @@protoc_insertion_point(field_get:dnd5e.ApiItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApiItem::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.ApiItem.name)
}
inline std::string* ApiItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.ApiItem.name)
  return _s;
}
inline const std::string& ApiItem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ApiItem::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ApiItem::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ApiItem::release_name() {
  // @@protoc_insertion_point(field_release:dnd5e.ApiItem.name)
  return _impl_.name_.Release();
}
inline void ApiItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.ApiItem.name)
}

// string url = 3;
inline void ApiItem::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& ApiItem::url() const {
  // @@protoc_insertion_point(field_get:dnd5e.ApiItem.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApiItem::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.ApiItem.url)
}
inline std::string* ApiItem::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:dnd5e.ApiItem.url)
  return _s;
}
inline const std::string& ApiItem::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ApiItem::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ApiItem::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ApiItem::release_url() {
  // @@protoc_insertion_point(field_release:dnd5e.ApiItem.url)
  return _impl_.url_.Release();
}
inline void ApiItem::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.ApiItem.url)
}

// string endpoint = 4;
inline void ApiItem::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& ApiItem::endpoint() const {
  // @@protoc_insertion_point(field_get:dnd5e.ApiItem.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApiItem::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.ApiItem.endpoint)
}
inline std::string* ApiItem::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:dnd5e.ApiItem.endpoint)
  return _s;
}
inline const std::string& ApiItem::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void ApiItem::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ApiItem::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* ApiItem::release_endpoint() {
  // @@protoc_insertion_point(field_release:dnd5e.ApiItem.endpoint)
  return _impl_.endpoint_.Release();
}
inline void ApiItem::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.ApiItem.endpoint)
}

// -------------------------------------------------------------------

// SearchResult

// .dnd5e.ApiItem item = 1;
inline bool SearchResult::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool SearchResult::has_item() const {
  return _internal_has_item();
}
inline void SearchResult::clear_item() {
  if (GetArenaForAllocation() == nullptr && _impl_.item_ != nullptr) {
    delete _impl_.item_;
  }
  _impl_.item_ = nullptr;
}
inline const ::dnd5e::ApiItem& SearchResult::_internal_item() const {
  const ::dnd5e::ApiItem* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::ApiItem&>(
      ::dnd5e::_ApiItem_default_instance_);
}
inline const ::dnd5e::ApiItem& SearchResult::item() const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchResult.item)
  return _internal_item();
}
inline void SearchResult::unsafe_arena_set_allocated_item(
    ::dnd5e::ApiItem* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.SearchResult.item)
}
inline ::dnd5e::ApiItem* SearchResult::release_item() {
  
  ::dnd5e::ApiItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dnd5e::ApiItem* SearchResult::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:dnd5e.SearchResult.item)
  
  ::dnd5e::ApiItem* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::dnd5e::ApiItem* SearchResult::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::dnd5e::ApiItem>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::dnd5e::ApiItem* SearchResult::mutable_item() {
  ::dnd5e::ApiItem* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:dnd5e.SearchResult.item)
  return _msg;
}
inline void SearchResult::set_allocated_item(::dnd5e::ApiItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:dnd5e.SearchResult.item)
}

// string matched_field = 2;
inline void SearchResult::clear_matched_field() {
  _impl_.matched_field_.ClearToEmpty();
}
inline const std::string& SearchResult::matched_field() const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchResult.matched_field)
  return _internal_matched_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResult::set_matched_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.matched_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dnd5e.SearchResult.matched_field)
}
inline std::string* SearchResult::mutable_matched_field() {
  std::string* _s = _internal_mutable_matched_field();
  // @@protoc_insertion_point(field_mutable:dnd5e.SearchResult.matched_field)
  return _s;
}
inline const std::string& SearchResult::_internal_matched_field() const {
  return _impl_.matched_field_.Get();
}
inline void SearchResult::_internal_set_matched_field(const std::string& value) {
  
  _impl_.matched_field_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchResult::_internal_mutable_matched_field() {
  
  return _impl_.matched_field_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchResult::release_matched_field() {
  // @@protoc_insertion_point(field_release:dnd5e.SearchResult.matched_field)
  return _impl_.matched_field_.Release();
}
inline void SearchResult::set_allocated_matched_field(std::string* matched_field) {
  if (matched_field != nullptr) {
    
  } else {
    
  }
  _impl_.matched_field_.SetAllocated(matched_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.matched_field_.IsDefault()) {
    _impl_.matched_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dnd5e.SearchResult.matched_field)
}

// float relevance_score = 3;
inline void SearchResult::clear_relevance_score() {
  _impl_.relevance_score_ = 0;
}
inline float SearchResult::_internal_relevance_score() const {
  return _impl_.relevance_score_;
}
inline float SearchResult::relevance_score() const {
  // @@protoc_insertion_point(field_get:dnd5e.SearchResult.relevance_score)
  return _internal_relevance_score();
}
inline void SearchResult::_internal_set_relevance_score(float value) {
  
  _impl_.relevance_score_ = value;
}
inline void SearchResult::set_relevance_score(float value) {
  _internal_set_relevance_score(value);
  // @@protoc_insertion_point(field_set:dnd5e.SearchResult.relevance_score)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dnd5e

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::dnd5e::HealthCheckResponse_ServingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dnd5e::HealthCheckResponse_ServingStatus>() {
  return ::dnd5e::HealthCheckResponse_ServingStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dnd5e_2eproto
